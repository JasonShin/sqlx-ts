"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[105],{6929:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"type-generation/annotations","title":"Annotations for overrides","description":"Annotation is a way to configure custom settings for the type generator. Here are the supported annotations","source":"@site/docs/type-generation/annotations.md","sourceDirName":"type-generation","slug":"/type-generation/annotations","permalink":"/sqlx-ts/type-generation/annotations","draft":false,"unlisted":false,"editUrl":"https://github.com/jasonshin/sqlx-ts/edit/main/book/docs/type-generation/annotations.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"DELETE statement","permalink":"/sqlx-ts/type-generation/delete"},"next":{"title":"Troubleshooting","permalink":"/sqlx-ts/troubleshooting"}}');var s=t(4848),i=t(8453);const o={sidebar_position:5},a="Annotations for overrides",l={},d=[{value:"Supported types",id:"supported-types",level:2},{value:"Overriding results",id:"overriding-results",level:2},{value:"Overriding params",id:"overriding-params",level:2},{value:"MySQL",id:"mysql",level:3},{value:"Postgres",id:"postgres",level:3}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"annotations-for-overrides",children:"Annotations for overrides"})}),"\n",(0,s.jsx)(n.p,{children:"Annotation is a way to configure custom settings for the type generator. Here are the supported annotations"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Annotation"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"@name"}),(0,s.jsx)(n.td,{children:"name to be used when generating types. It will override the default name (variable name) and it will be formatted in camelcase."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"@db"}),(0,s.jsxs)(n.td,{children:["name of the database you'd like to use for the query. By default it will use ",(0,s.jsx)(n.code,{children:"default"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"@result [name]"}),(0,s.jsx)(n.td,{children:"override result type of a field in a query"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"@param  [index]"}),(0,s.jsx)(n.td,{children:"override parameter type of a field in a query"})]})]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// example\nconst someQuery = sql`\n-- @name: simpleQuery\n-- @db: mysql\nSELECT *\nFROM items;\n`\n"})}),"\n",(0,s.jsx)(n.p,{children:"Above example query will generate following types"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export type SimpleQueryParams = []\n\nexport interface ISimpleQueryResult {\n    id: string\n    points: number\n}\n\nexport interface ISimpleQueryQuery{\n    params: SimpleQueryParams;\n    result: ISimpleQueryResult;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that types are generated with ",(0,s.jsx)(n.code,{children:"SimpleQuery"})," namespace instead of the variable name ",(0,s.jsx)(n.code,{children:"SomeQuery"}),". This is the result of setting ",(0,s.jsx)(n.code,{children:"@name"})," annotation\nin the query. Also, it will use ",(0,s.jsx)(n.code,{children:"mysql"})," database connection that you configured in ",(0,s.jsx)(n.code,{children:".sqlxrc.json"})," as a result of setting ",(0,s.jsx)(n.code,{children:"@db"}),"."]}),"\n",(0,s.jsx)(n.h1,{id:"overrides",children:"Overrides"}),"\n",(0,s.jsxs)(n.p,{children:["SQLX-TS cannot generate typing for complex SQL syntax such as JSON functions. In this scenario, sqlx-ts will return ",(0,s.jsx)(n.code,{children:"any"})," and you can use annotations\nto override the result to a type that you anticipate."]}),"\n",(0,s.jsx)(n.h2,{id:"supported-types",children:"Supported types"}),"\n",(0,s.jsxs)(n.p,{children:["Type override supports these types ",(0,s.jsx)(n.code,{children:"string"}),", ",(0,s.jsx)(n.code,{children:"number"}),", ",(0,s.jsx)(n.code,{children:"boolean"}),", ",(0,s.jsx)(n.code,{children:"object"}),", ",(0,s.jsx)(n.code,{children:"null"}),", ",(0,s.jsx)(n.code,{children:"any"}),", and ",(0,s.jsx)(n.code,{children:"never"})]}),"\n",(0,s.jsx)(n.h2,{id:"overriding-results",children:"Overriding results"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const someQuery = sql`\n-- @result points: number | null\nSELECT\n    id,\n    JSON_EXTRACT(items.c, "$.points") as points\nFROM items\n`\n'})}),"\n",(0,s.jsx)(n.p,{children:"would generate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export type SimpleQueryParams = []\n\nexport interface ISimpleQueryResult {\n    id: string\n    points: number\n}\n\nexport interface ISimpleQueryQuery{\n    params: SimpleQueryParams;\n    result: ISimpleQueryResult;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"It's important that you give it an alias so SQLX-TS can match it with your custom annotation."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Rust provides pattern matching that enforces you to handle all patterns of an enum.\nBased on this, we can exhaustively handle all SQL syntax and narrow down the patterns that SQLX-TS cannot handle.\nIf you ever use following SQL syntax, it is encouraged to override the type using @result annotation."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"overriding-params",children:"Overriding params"}),"\n",(0,s.jsxs)(n.p,{children:["Overriding generated type for a param works by adding an annotation ",(0,s.jsx)(n.code,{children:"-- @param <index>: type"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"index"})," is the position of the query parameter within your SQL"]}),"\n",(0,s.jsx)(n.li,{children:"type is the type to override"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"mysql",children:"MySQL"}),"\n",(0,s.jsx)(n.p,{children:"If you have a MySQL query like following, you can override param types like in the example below"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const someQuery = sql`\n-- @db: mysql\n-- @param 1: number\n-- @param 2: string\nSELECT\n    id, points\nFROM items\nWHERE points < ?\nAND name = ?\n`\n"})}),"\n",(0,s.jsx)(n.p,{children:"it would generate the following type definitions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export type SimpleQueryParams = [number, string]\n\nexport interface ISimpleQueryResult {\n    id: string\n    points: number\n}\n\nexport interface ISimpleQueryQuery{\n    params: SimpleQueryParams;\n    result: ISimpleQueryResult;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"postgres",children:"Postgres"}),"\n",(0,s.jsx)(n.p,{children:"If you have a Postgres query like following, you can override param types like in the example below"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const someQuery = sql`\n-- @db: postgres\n-- @param 1: number\n-- @param 2: string\nSELECT\n    id, points\nFROM items\nWHERE points < $2\nAND name = $1\n`\n"})}),"\n",(0,s.jsx)(n.p,{children:"it would generate the following type definitions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export type SimpleQueryParams = [string, number]\n\nexport interface ISimpleQueryResult {\n    id: string\n    points: number\n}\n\nexport interface ISimpleQueryQuery{\n    params: SimpleQueryParams;\n    result: ISimpleQueryResult;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It will respect the order of query parameters set by you ",(0,s.jsx)(n.code,{children:"$1"})," and ",(0,s.jsx)(n.code,{children:"$2"}),", and generate the params in the order that it detects"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);