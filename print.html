<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sqlx-ts</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Guides</li><li class="chapter-item expanded "><a href="guides/0.introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="guides/1.getting-started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/1.1.install_sh_cli_options.html"><strong aria-hidden="true">2.1.</strong> curl approach</a></li></ol></li><li class="chapter-item expanded "><a href="guides/2.configuration.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li class="chapter-item expanded affix "><li class="part-title">API</li><li class="chapter-item expanded "><a href="api/1.connecting-to-db.html"><strong aria-hidden="true">4.</strong> Connecting to databases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/1.3.configs-file-based.html"><strong aria-hidden="true">4.1.</strong> .sqlxrc file</a></li><li class="chapter-item expanded "><a href="api/1.1.cli-options.html"><strong aria-hidden="true">4.2.</strong> CLI options</a></li><li class="chapter-item expanded "><a href="api/1.2.environment-variables.html"><strong aria-hidden="true">4.3.</strong> environment variables</a></li></ol></li><li class="chapter-item expanded "><a href="api/2.ignore-patterns.html"><strong aria-hidden="true">5.</strong> .sqlxignore file</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="reference-guide/1.sql-check.html"><strong aria-hidden="true">6.</strong> SQL Check</a></li><li class="chapter-item expanded "><a href="reference-guide/4.typescript-types-generation.html"><strong aria-hidden="true">7.</strong> Type generation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/4.1.SELECT.html"><strong aria-hidden="true">7.1.</strong> SELECT</a></li><li class="chapter-item expanded "><a href="reference-guide/4.2.INSERT.html"><strong aria-hidden="true">7.2.</strong> INSERT</a></li><li class="chapter-item expanded "><a href="reference-guide/4.3.DELETE.html"><strong aria-hidden="true">7.3.</strong> DELETE</a></li><li class="chapter-item expanded "><a href="reference-guide/4.4.UPDATE.html"><strong aria-hidden="true">7.4.</strong> UPDATE</a></li><li class="chapter-item expanded "><a href="reference-guide/4.5.annotations.html"><strong aria-hidden="true">7.5.</strong> Annotations</a></li></ol></li><li class="chapter-item expanded "><a href="reference-guide/5.errors.html"><strong aria-hidden="true">8.</strong> Errors</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="misc/1.troubleshooting.html"><strong aria-hidden="true">9.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="misc/2.limitations.html"><strong aria-hidden="true">10.</strong> Limitations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">sqlx-ts</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div align="center">
<img src="./assets/sqlx-ts-logo.png" width="70%" />
</div>
<div align="center">
 <strong>
   ðŸ§° The Typescript/Javascript SQL Toolkit
 </strong>
</div>
<br />
<p>SQLx-ts is a CLI application featuring compile-time checked queries without a DSL and generates types against SQLs to keep your code type-safe</p>
<ul>
<li><strong>Compile time checked queries</strong> - never ship a broken SQL query to production (and <a href="https://github.com/JasonShin/sqlx-ts#sqlx-ts-is-not-an-orm">sqlx-ts is not an ORM</a>)</li>
<li><strong>TypeScript type generations</strong> - generates type definitions based on the raw SQLs and you can use them with any MySQL or PostgreSQL driver</li>
<li><strong>Database Agnostic</strong> - support for <a href="http://postgresql.org/">PostgreSQL</a> and <a href="https://www.mysql.com/">MySQL</a> (and more DB supports to come)</li>
<li><strong>TypeScript and JavaScript</strong> - supports for both <a href="https://jasonshin.github.io/sqlx-ts/reference-guide/4.typescript-types-generation.html">TypeScript</a> and <a href="https://github.com/JasonShin/sqlx-ts#using-sqlx-ts-in-vanilla-javascript">JavaScript</a></li>
</ul>
<h3 id="sqlx-ts-is-not-an-orm"><a class="header" href="#sqlx-ts-is-not-an-orm">sqlx-ts is not an ORM!</a></h3>
<p>sqlx-ts supports <strong>compile-time checked queries</strong> and <strong>generated types against SQLs</strong>. It does not, however, do this by providing DSL (domain-specific language) for building queries. Instead, it provides macros that take regular SQL as input and ensure that it is valid against the target database. The way it works is that sqlx-ts connects to your local or development database at compile-time and have database itself to verify the queries, also generate types based on information_schema. This can have many benefits that typical ORMs cannot provide</p>
<ul>
<li>Since sqlx-ts simply sends the queries back to the DB, almost any SQL syntax can be used in sqlx-ts (including things added by database extensions)</li>
<li>You can easily optimize the queries as the SQLs are not built using a query-builder or an ORM interface</li>
<li>The generated types work well with almost any database driver or even ORMs if they have good typescript support (that allows you to override input and output types)</li>
</ul>
<p>but it comes with some implications</p>
<ul>
<li>The amount of information that sqlx-ts retrieves depend on the type of the database (e.g. MySQL vs PostgreSQL)</li>
</ul>
<p>If you are looking for an ORM, you can checkout <a href="https://sequelize.org/">Sequelize</a> or <a href="https://www.prisma.io/">Prisma</a>.</p>
<h3 id="using-sqlx-ts-in-vanilla-javascript"><a class="header" href="#using-sqlx-ts-in-vanilla-javascript">Using sqlx-ts in vanilla JavaScript</a></h3>
<p>If you are trying to use sqlx-ts against vanilla JS, the <a href="https://jasonshin.github.io/sqlx-ts/reference-guide/4.typescript-types-generation.html">TypeScript type-generation</a> feature wouldn't be helpful. You can simply use <a href="https://jasonshin.github.io/sqlx-ts/reference-guide/1.sql-check.html">SQL Check</a> feature to keep your SQLs in JS code safe and compile-time checked.</p>
<h3 id="motivation"><a class="header" href="#motivation">Motivation</a></h3>
<p>I would like to bring the powerful compile-time safety ideas to Node.js. <a href="https://github.com/launchbadge/sqlx">sqlx</a> is a great example of this, as it provides compile-time check of SQLs within your Rust code and Rust itself provides a great environment for tools like sqlx. sqlx-ts is greatly inspired by <a href="https://github.com/launchbadge/sqlx">sqlx</a>, but solves additional problems of generating TypeScript interfaces based on the SQL queries that are present in your code.</p>
<div>
Introduction
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/JasonShin/sqlx-ts">sqlx-ts</a> is a standalone CLI tool to validate and type generate against SQLs during compile-time of your Node/TypeScript projects. sqlx-ts is database agnostic (works with MySQL, Postgres and more).</p>
<h2 id="validates-sqls-in-your-code-at-compile-time"><a class="header" href="#validates-sqls-in-your-code-at-compile-time">validates SQLs in your code at compile time</a></h2>
<iframe width="860" height="455" src="https://www.youtube.com/embed/ogt_bfSnBgA?si=l36NnG2iKihxg5CW&amp;controls=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<h2 id="generate-types-for-type-safety"><a class="header" href="#generate-types-for-type-safety">generate types for type-safety</a></h2>
<iframe width="860" height="455" src="https://www.youtube.com/embed/Ja6ICucRHu0?si=z8gCYsplAW_zECsG&amp;controls=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<h2 id="works-with-multiple-types-of-databases"><a class="header" href="#works-with-multiple-types-of-databases">works with multiple types of databases</a></h2>
<iframe width="860" height="455" src="https://www.youtube.com/embed/YKITTWm5yKM?si=dHQhK69VZFLV5t8l&amp;controls=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<h2 id="supports-select-update-delete-and-insert-statements"><a class="header" href="#supports-select-update-delete-and-insert-statements">supports SELECT, UPDATE, DELETE, and INSERT statements</a></h2>
<iframe width="860" height="455" src="https://www.youtube.com/embed/0_tqqNM1kRQ?si=LcPy7s0Rwz9l5Vz4&amp;controls=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Make sure that you have Node.js (&gt; v12) and TypeScript installed.
Also, you must have <a href="https://curl.se/">curl</a> available as it is required during the installation steps.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>With npm:</p>
<pre><code class="language-bash">$ npm install sqlx-ts
</code></pre>
<p>With yarn:</p>
<pre><code class="language-bash">$ yarn add sqlx-ts
</code></pre>
<p>Verify the installation of <code>sqlx-ts</code> binary by running</p>
<pre><code class="language-bash">$ npx sqlx-ts --version
</code></pre>
<p>ðŸš€ you now have <code>sqlx-ts</code> installed ðŸš€</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curl-installation-approach"><a class="header" href="#curl-installation-approach">curl installation approach</a></h1>
<p>You can decide to install sqlx-ts independently using a simple <code>curl</code> command.</p>
<p><em><strong>NOTE</strong></em>:  This is not an usual way to install to use sqlx-ts. However, it can be used in an environment without NPM.</p>
<p>Examples:</p>
<pre><code class="language-bash"># The following command will install sqlx-ts (v0.9.0) for MacOS (darwin) with M1 CPU (arm64)
# overwrite the existing sqlx-ts (-f) at the default installation location (pwd)
curl -LSfs https://jasonshin.github.io/sqlx-ts/install.sh | bash -s -- \
    --os darwin
    --cpu arm64
    --tag v0.9.0
    -f
</code></pre>
<p>You can find more information about the <code>install.sh</code></p>
<pre><code class="language-bash">curl -LSfs https://jasonshin.github.io/sqlx-ts/install.sh | bash -s -- \
    --help
</code></pre>
<p>You can find the latest releases of sqlx-ts here to find an appropriate value for <code>--tag</code></p>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>-h --help</td><td>Help command to display all available</td></tr>
<tr><td>-f --force</td><td>Force overwriting an existing binary. Useful when you'd like to update or downgrade the binary</td></tr>
<tr><td>--os</td><td>Your current OS, it's used to determine the type of binary to be installed (one of macos or win32 or linux)</td></tr>
<tr><td>--artifact</td><td>Specific artifact to install. Please find the artifact name from https://github.com/JasonShin/sqlx-ts/releases (e.g. sqlx_ts_v0.1.0_x86_64-apple-darwin.zip)</td></tr>
<tr><td>--tag</td><td>Tag (version) of the crate to install (default )</td></tr>
<tr><td>--to</td><td>Where to install the binary (default to <code>.</code> or <code>pwd</code> current diretory)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<h2 id="example-1-single-database-connection-using-cli-options"><a class="header" href="#example-1-single-database-connection-using-cli-options">Example 1: Single database connection using CLI options</a></h2>
<p>Run this in your terminal</p>
<pre><code class="language-bash">sqlx-ts ./src/app \
    --db-host=127.0.0.1 \ 
    --db-port=54321 \
    --db-type=postgres \
    --db-user=postgres \
    --db-pass=postgres \
    --generate-types
</code></pre>
<p>The CLI can be triggered in this format sqlx-ts <path to source code> <options> check the CLI Options page for more details.</p>
<h2 id="example-2-single-database-connection-using-sqlxrcjson-file"><a class="header" href="#example-2-single-database-connection-using-sqlxrcjson-file">Example 2: single database connection using <code>.sqlxrc.json</code> file</a></h2>
<p>Create a file called <code>.sqlxrc.json</code>  at the root level of your project where you will run sqlx-ts binary</p>
<pre><code class="language-json">{
  &quot;generateTypes&quot;: {
    &quot;enabled&quot;: true
  },
  &quot;connections&quot;: {
    &quot;default&quot;: {
      &quot;DB_TYPE&quot;: &quot;postgres&quot;,
      &quot;DB_HOST&quot;: &quot;127.0.0.1&quot;,
      &quot;DB_PORT&quot;: 54321,
      &quot;DB_USER&quot;: &quot;postgres&quot;,
      &quot;DB_PASS&quot;: &quot;postgres&quot;,
      &quot;DB_NAME&quot;: &quot;postgres&quot;
    }
  }
}
</code></pre>
<p>Then run this in your terminal</p>
<pre><code class="language-bash">cargo run ./src/app --config .sqlxrc.json
</code></pre>
<h2 id="example-3-multiple-database-connections-using-sqlxrcjson-file"><a class="header" href="#example-3-multiple-database-connections-using-sqlxrcjson-file">Example 3: Multiple database connections using <code>.sqlxrc.json</code> file</a></h2>
<p>Create a file called <code>.sqlxrc.json</code>  at the root level of your project where you will run sqlx-ts binary</p>
<pre><code class="language-json">{
  &quot;generateTypes&quot;: {
    &quot;enabled&quot;: true
  },
  &quot;connections&quot;: {
    &quot;default&quot;: {
      &quot;DB_TYPE&quot;: &quot;postgres&quot;,
      &quot;DB_HOST&quot;: &quot;127.0.0.1&quot;,
      &quot;DB_PORT&quot;: 4321,
      &quot;DB_USER&quot;: &quot;postgres&quot;,
      &quot;DB_PASS&quot;: &quot;postgres&quot;,
      &quot;DB_NAME&quot;: &quot;postgres&quot;
    },
    &quot;mysql&quot;: {
      &quot;DB_TYPE&quot;: &quot;mysql&quot;,
      &quot;DB_HOST&quot;: &quot;127.0.0.1&quot;,
      &quot;DB_PORT&quot;: 3306,
      &quot;DB_USER&quot;: &quot;root&quot;,
      &quot;DB_NAME&quot;: &quot;mysql&quot;
    }
  }
}
</code></pre>
<p>Then run this in your terminal</p>
<pre><code class="language-bash">cargo run ./src/app --config .sqlxrc.json
</code></pre>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p>By default, sql check operation ignores <code>node_modules</code>. Any extra ignore paths can be specified 
using <code>--ignore=&lt;path&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-to-databases"><a class="header" href="#connecting-to-databases">Connecting to databases</a></h1>
<p><code>sqlx-ts</code> supports the following approach connect to the database</p>
<ol>
<li><a href="api/./1.3.configs-file-based.html">File based configuration</a></li>
<li><a href="api/./1.1.cli-options.html">CLI options</a></li>
<li><a href="api/./1.2.environment-variables.html">Environment variables</a></li>
</ol>
<p>If you provide database host by a CLI option and an environment variable, CLI option will take 
the priority over the environment variable.</p>
<h3 id="1-file-based-config"><a class="header" href="#1-file-based-config">1. File based config</a></h3>
<p>If your project needs connections to multiple databases for SQL check, you have to use the file 
based config and specify connection details for those databases. <a href="api/./1.3.configs-file-based.html">Please check here for more details</a></p>
<h3 id="2-cli-options"><a class="header" href="#2-cli-options">2. CLI options</a></h3>
<p>You can only configure the primary database connection through CLI options. <a href="api/./1.1.cli-options.html">Please check here for more details</a></p>
<h3 id="3-environment-variables"><a class="header" href="#3-environment-variables">3. Environment variables</a></h3>
<p>You can only configure the primary database connection through environment variables. <a href="api/./1.2.environment-variables.html">Please check here for more details</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-base-configuration-for-connecting-to-multiple-db"><a class="header" href="#file-base-configuration-for-connecting-to-multiple-db">File Base Configuration for connecting to Multiple DB</a></h1>
<p>If you have a project that you need requires connections to multiple databases, you can support 
that by using file based configuration.</p>
<p>By default, configuration file is named <code>.sqlxrc.json</code> and sqlx-ts will try to find a file with 
this name, unless you give it a custom path to override it using <code>--config</code> CLI option.</p>
<pre><code class="language-bash">$ sqlx-ts --config &lt;path to a custom .sqlxrc.json&gt;
</code></pre>
<p>Example <code>sqlxrc.json</code></p>
<pre><code class="language-json">{
  &quot;generate_types&quot;: {
    &quot;enabled&quot;: true,
    &quot;convertToCamelCaseColumnName&quot;: true
  },
  &quot;connections&quot;: {
    &quot;default&quot;: {
      &quot;DB_TYPE&quot;: &quot;mysql&quot;,
      &quot;DB_USER&quot;: &quot;root&quot;,
      &quot;DB_HOST&quot;: &quot;127.0.0.1&quot;,
      &quot;DB_PORT&quot;: 3306
    },
    &quot;postgres&quot;: {
      &quot;DB_TYPE&quot;: &quot;postgres&quot;,
      &quot;DB_USER&quot;: &quot;postgres&quot;,
      &quot;DB_PASS&quot;: &quot;postgres&quot;,
      &quot;DB_HOST&quot;: &quot;127.0.0.1&quot;,
      &quot;DB_PORT&quot;: 4321,
      &quot;PG_SEARCH_PATH&quot;: &quot;public,myschema&quot;
    },
    &quot;some_other_db&quot;: {
      &quot;DB_TYPE&quot;: &quot;mysql&quot;,
      &quot;DB_USER&quot;: &quot;app_user&quot;,
      &quot;DB_PASS&quot;: &quot;password&quot;,
      &quot;DB_HOST&quot;: &quot;127.0.0.1&quot;,
      &quot;DB_PORT&quot;: 3307
    }
  }
}
</code></pre>
<h3 id="required-connections"><a class="header" href="#required-connections">(required) &quot;connections&quot;</a></h3>
<p>For default database, you must call it <code>default</code> like example above. Any extra DB connections 
should have its own unique name such as <code>postgres</code> or <code>some_other_db</code></p>
<p>Along with the configuration above, when writing SQLs in your codebase, you need to provide 
supportive comment in your raw SQL, indicate which database the query should point.</p>
<p>For example,</p>
<pre><code class="language-typescript">import { sql } from 'sqlx-ts'

// targets the default DB
const defaultDbSQL = sql`SELECT * FROM test;`
// targets the config with the name `postgres`
const postgresSQL = sql`
 -- @db: postgres
 SELECT * FROM other_table;
`
</code></pre>
<p>Supported fields of each connection include</p>
<ul>
<li><code>DB_TYPE</code>: type of database connection (mysql | postgres)</li>
<li><code>DB_USER</code>: database user name</li>
<li><code>DB_PASS</code>: database password</li>
<li><code>DB_HOST</code>: database host (e.g. 127.0.0.1)</li>
<li><code>DB_PORT</code>: database port (e.g. 4321)</li>
<li><code>PG_SEARCH_PATH</code>: PostgreSQL schema search path (default is &quot;$user,public&quot;) <a href="https://www.postgresql.org/docs/current/ddl-schemas.html#DDL-SCHEMAS-PATH">https://www.postgresql.org/docs/current/ddl-schemas.html#DDL-SCHEMAS-PATH</a></li>
</ul>
<h3 id="generate_types"><a class="header" href="#generate_types">generate_types</a></h3>
<pre><code class="language-json">{
  &quot;generateTypes: {
    enabled: true|false,
    convertToCamelCaseColumnName: true|false
  },
  &quot;connections&quot;: {
    ...
  }
}
</code></pre>
<p>Support for configuration of generate types operations.</p>
<ul>
<li><code>enabled</code> (default: false): enables type generation via config</li>
<li><code>convertToCamelCaseColumnName</code> (default: true): when generating field name based on table's column name, it will automatically cast to camelCase in TypeScript</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqlx-ts-cli-opitons"><a class="header" href="#sqlx-ts-cli-opitons">sqlx-ts CLI Opitons</a></h1>
<p>To check the latest CLI options available, please run</p>
<pre><code class="language-bash">$ sqlx-ts --help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Environment variables</th><th>Description</th></tr></thead><tbody>
<tr><td>DB_HOST</td><td>Primary DB host</td></tr>
<tr><td>DB_PASS</td><td>Primary DB password</td></tr>
<tr><td>DB_PORT</td><td>Primary DB port number</td></tr>
<tr><td>DB_TYPE</td><td>Type of primary database to connect [default: postgres] [possible values: postgres, mysql]</td></tr>
<tr><td>DB_USER</td><td>Primary DB user name</td></tr>
<tr><td>DB_NAME</td><td>Primary DB name</td></tr>
<tr><td>PG_SEARCH_PATH</td><td>PostgreSQL schema search path (default is &quot;$user,public&quot;) <a href="https://www.postgresql.org/docs/current/ddl-schemas.html#DDL-SCHEMAS-PATH">https://www.postgresql.org/docs/current/ddl-schemas.html#DDL-SCHEMAS-PATH</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="sqlxignore"><a class="header" href="#sqlxignore">.sqlxignore</a></h1>
<p>you can use <code>.sqlxignore</code> file in order to ignore certain files from being processed.</p>
<p>By default, <code>*.queries.ts</code> are ignored by sqlx-ts as these files are the default extension of generated types.</p>
<p>You can include more files in the ignore list by creating <code>.sqlxignore</code></p>
<pre><code>*.queries.ts
*.something.*
</code></pre>
<p><code>*</code> ignores all matching patterns.</p>
<ul>
<li>The first one ignores all files with <code>.queries.ts</code> extension</li>
<li>The second one ignores all files that has <code>.something.</code> as part of the file path / name</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-check"><a class="header" href="#sql-check">SQL Check</a></h1>
<p>Checking SQL is the core functionality of sqlx-ts. It is the default command when you run 
<code>sqlx-ts</code> binary as well.</p>
<p>By default, you pass in connection options to connect to the primary database. You can configure how 
sqlx-ts figures out database connection configurations by checking out the <a href="reference-guide/../guides/2.configuration.html">configuration page</a></p>
<h2 id="running-sqlx-ts-to-check-sqls"><a class="header" href="#running-sqlx-ts-to-check-sqls">Running sqlx-ts to check SQLs</a></h2>
<pre><code class="language-bash">sqlx-ts &lt;path-to-node-project&gt; \
  --config .sqlxrc.json \
  -g
</code></pre>
<p>As a result, you'd get, for example:</p>
<img src="reference-guide/../assets/postgres-check-success.png">
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-types-generation"><a class="header" href="#typescript-types-generation">TypeScript Types Generation</a></h1>
<p>sqlx-ts provides the powerful Typescript type generation based on the raw SQLs that you write in your code.
The feature greatly enhances type safety of the raw SQL queries, ultimately replaces the need of ORM completely.</p>
<p>Without type generation, you would maintain type definition of each raw SQL manually, which is a brittle process and
becomes an extra management in large projects.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h2>
<p>The simplest way to use type generation feature of sqlx-ts is by setting <code>-g</code> or <code>--generate-types</code> flag when running sqlx-ts CLI.</p>
<pre><code class="language-bash">$ cargo run ./samples/type-generator-test --generate-types --config=&lt;path to .sqlxrc.json&gt;
</code></pre>
<p>By default, sqlx-ts will generate type</p>
<p><a href="reference-guide/./2.1.configs-file-based.html">Please read more about .sqlxrc.json here</a></p>
<h2 id="whats-possible"><a class="header" href="#whats-possible">What's possible</a></h2>
<p>sqlx-ts supports following type generations and other SQL syntax will be ignored from type generation</p>
<ul>
<li>SELECT statements</li>
<li>INSERT statements</li>
<li>UPDATE statements</li>
<li>DELETE statements</li>
</ul>
<p>Also type generation supports parameterised query as per the requirements of PREPARE statements of the databases
that sqlx-ts currently supports.</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/prepare.html">MySQL PREPARE</a></li>
<li><a href="https://www.postgresql.org/docs/current/sql-prepare.html">Postgres PREPARE</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Database</th><th>Parameterised Query</th><th>Example</th></tr></thead><tbody>
<tr><td>MySQL</td><td>?</td><td>SELECT * FROM items WHERE points &gt; ? AND points &lt; ?</td></tr>
<tr><td>Postgres</td><td>$1 $2 $3</td><td>SELECT * FROM items WHERE points &gt; $1 AND points &lt; $2</td></tr>
</tbody></table>
</div>
<p>in your codebase, if you have the following SQL query</p>
<pre><code class="language-typescript">const simpleQuery = sql`
SELECT *
FROM items
WHERE points &gt; ?
AND points &lt; ?
`
</code></pre>
<p>by running sqlx-ts type generation against the query, it would generate</p>
<pre><code class="language-typescript">export type ISimpleQueryParams = [number, number]

export interface ISimpleQueryResult {
    id: string
    points: number
}

export interface ISimpleQueryQuery{
    params: ISimpleQueryParams;
    result: ISimpleQueryResult;
}
</code></pre>
<p>sqlx-ts will pick up name of the variable and use it when generating the type definitions. You can override 
the type name by setting the <code>@name</code> annotation, you can read more in the section <a href="reference-guide/4.typescript-types-generation.html#annotations">below</a>.</p>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>You can configure type generation in <code>.sqlxrc.json</code>; available configurations:</p>
<p><strong>Todo</strong>
We need configurations for following:</p>
<ul>
<li>generate type paths</li>
<li>file names (by default, it should be file_name.types.ts)</li>
</ul>
<h2 id="qa"><a class="header" href="#qa">Q/A</a></h2>
<h5 id="why-doesnt-sqlx-support-named-parameterised-queries-eg-select--from-items-where-point--point"><a class="header" href="#why-doesnt-sqlx-support-named-parameterised-queries-eg-select--from-items-where-point--point">Why doesn't SQLx support named parameterised queries? <code>e.g. SELECT * FROM items WHERE point = :point</code></a></h5>
<p>We believe that there is no official way in Typescript to ensure the value level type-safety yet and providing named parameter does not guarantee
the true type safetiness that we are trying to achieve. Furthermore, name parameter is not the syntax supported by native database drivers, but 
they are an additional syntax supported by popular ORM libraries such as Sequelize.</p>
<p>The closest type safety that exists in TypeScript world is by emulating Opaque type e.g. https://github.com/sindresorhus/type-fest/blob/main/source/opaque.d.ts.
In the future, sqlx-ts will support Opaque type overrides natively to solve this matter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select-statement"><a class="header" href="#select-statement">SELECT statement</a></h1>
<p>Parameter is way to denote value replacements in a SQL query. Each database uses
different placeholder symbol:</p>
<div class="table-wrapper"><table><thead><tr><th>database</th><th>placeholder symbol</th><th>Example</th></tr></thead><tbody>
<tr><td>MySQL</td><td><code>?</code></td><td><code>SELECT * FROM items WHERE points &gt; ?</code></td></tr>
<tr><td>PostgreSQL</td><td><code>$1</code> <code>$2</code> <code>$3</code> ... <code>$n</code></td><td><code>SELECT * FROM items WHERE points &gt; $1</code></td></tr>
</tbody></table>
</div>
<p>Based on your target database, you should use its known placeholder symbol. sqlx-ts is able to handle both MySQL and PostgreSQL placeholder syntax.</p>
<h2 id="example-database"><a class="header" href="#example-database">Example database</a></h2>
<p>Throughout this section of the guide, we will be using the following database ERD</p>
<img src="reference-guide/../assets/example-erd.png" />
<h2 id="binary-operations"><a class="header" href="#binary-operations">Binary operations</a></h2>
<p>If you have the follow MySQL query in typescript</p>
<pre><code class="language-typescript">// example
const someQuery = sql`
SELECT *
FROM items
WHERE points &gt; ?;
</code></pre>
<p>would generate</p>
<pre><code class="language-typescript">export type SomeQueryParams = []

export interface ISomeQueryResult {
    id: string
    points: number
}

export interface ISomeQueryQuery {
    params: SomeQueryParams;
    result: ISomeQueryResult;
}
</code></pre>
<h2 id="in-list-query"><a class="header" href="#in-list-query">IN list query</a></h2>
<p>If you have the following MySQL query</p>
<pre><code class="language-typescript">// example
const someQuery = sql`
SELECT *
FROM items
WHERE id IN (?);
</code></pre>
<p>would generate following typescript types</p>
<pre><code class="language-typescript">export type SomeQueryParams = [Array&lt;number&gt;]

export interface ISomeQueryResult {
    id: string
    points: number
}

export interface ISomeQueryQuery {
    params: SomeQueryParams;
    result: ISomeQueryResult;
}
</code></pre>
<h2 id="subqueries"><a class="header" href="#subqueries">Subqueries</a></h2>
<p>Query params within subqueries are interpreted as well. If you have the following MySQL query</p>
<pre><code class="language-typescript">const someQuery = sql`
SELECT id, points
FROM items
WHERE id IN (
    SELECT id FROM items
    WHERE
        points &gt; ?
        AND id IN (SELECT id FROM items WHERE food_type = ?)
)
AND points &lt; ?
`
</code></pre>
<p>would generate following type definitions</p>
<pre><code class="language-typescript">export type SomeQueryParams = [number, string, number]

export interface ISomeQueryResult {
    id: string
    points: number
}

export interface ISomeQueryQuery {
    params: SomeQueryParams;
    result: ISomeQueryResult;
}
</code></pre>
<p>Note that <code>QueryParams</code> array respects the order of params present in the query above</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="insert-statement"><a class="header" href="#insert-statement">INSERT statement</a></h1>
<p>To read more about how sqlx-ts translates query parameters, <a href="reference-guide/./4.1.SELECT.html">visit this page</a></p>
<h4 id="mysql"><a class="header" href="#mysql">MySQL</a></h4>
<p>Query params within an insert statement can be converted into TypeScript types as well</p>
<pre><code class="language-typescript">const someQuery = sql`
INSERT INTO items (id, food_type, time_takes_to_cook, table_id, points)
VALUES
    (?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?);
`
</code></pre>
<p>would generate following</p>
<pre><code class="language-typescript">export type SomeQueryParams = [
    [number, string, number, number, number],
    [number, string, number, number, number]
]

export interface ISomeQueryQuery {
    params: SomeQueryParams
    result: null
}
</code></pre>
<h4 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h4>
<p>As query params of PostgresSQL uses the numbered paramters, it's meaningless to generate a nested array respresnetation of them.</p>
<p>If you have</p>
<pre><code class="language-typescript">const somePostgresInputQuery = sql`
INSERT INTO items (id, food_type, time_takes_to_cook, table_id, points)
VALUES
($2, $1, 2, $3, 2),
($5, 'test', $4, $7, $6);
`
</code></pre>
<p>Above query will generate the following typings</p>
<pre><code class="language-typescript">export type SomePostgresInputQueryParams = [string, number, number, number, number, number, number];

export interface ISomePostgresInputQueryResult {
    
};

export interface ISomePostgresInputQueryQuery {
    params: SomePostgresInputQueryParams;
    result: ISomePostgresInputQueryResult;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-statement"><a class="header" href="#delete-statement">DELETE statement</a></h1>
<p>To read more about how sqlx-ts translates query parameters, <a href="reference-guide/./4.1.SELECT.html">visit this page</a></p>
<h4 id="mysql-1"><a class="header" href="#mysql-1">MySQL</a></h4>
<p>Query params within a DELETE statement will be converted Typescript types</p>
<pre><code class="language-typescript">const someQuery = sql`
DELETE FROM items WHERE id = ?
`
</code></pre>
<p>would generate following</p>
<pre><code class="language-typescript">export type SomeQueryParams = [number]

export interface ISomeQueryQuery {
    params: SomeQueryParams
    results: null
}
</code></pre>
<h4 id="postgresql-1"><a class="header" href="#postgresql-1">PostgreSQL</a></h4>
<p>If you the following query in your Typescript code</p>
<pre><code class="language-typescript">const someQuery = sql`
DELETE FROM items WHERE id = $1;
`
</code></pre>
<p>would result in</p>
<pre><code class="language-typescript">export type SomeQueryParams = [number]

export interface ISomeQueryQuery {
    params: SomeQueryParams
    results: null
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-statement"><a class="header" href="#update-statement">UPDATE statement</a></h1>
<p>To read more about how sqlx-ts translates query parameters, <a href="reference-guide/./4.1.SELECT.html">visit this page</a></p>
<h4 id="mysql-2"><a class="header" href="#mysql-2">MySQL</a></h4>
<p>Query params within an update statement can be converted into TypeScript types as well</p>
<pre><code class="language-typescript">const someQuery = sql`
UPDATE items
JOIN tables ON tables.id = items.table_id
SET items.food_type = ?
WHERE tables.id = ?
`
</code></pre>
<p>would generate following</p>
<pre><code class="language-typescript">export type SomeQueryParams = [string, number]

export type SomeQueryResult = number

export interface ISomeQueryQuery {
    params: SomeQueryParams
    result: SomeQueryResult
}
</code></pre>
<h4 id="postgresql-2"><a class="header" href="#postgresql-2">PostgreSQL</a></h4>
<p>As query params of PostgresSQL uses the numbered paramters, it's meaningless to generate a nested array respresnetation of them.</p>
<p>If you have</p>
<pre><code class="language-typescript">const someQuery = sql`
UPDATE items
JOIN tables ON tables.id = items.table_id
SET items.food_type = $2
WHERE tables.id = $1
`
</code></pre>
<p>Above query will generate the following typings</p>
<pre><code class="language-typescript">export type SomePostgresInputQueryParams = [string, number, number, number, number, number, number];

export interface ISomePostgresInputQueryResult {
    
};

export interface ISomePostgresInputQueryQuery {
    params: SomePostgresInputQueryParams;
    result: ISomePostgresInputQueryResult;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotations"><a class="header" href="#annotations">Annotations</a></h1>
<p>Annotation is a way to configure custom settings for the type generator. Here are the supported annotations</p>
<div class="table-wrapper"><table><thead><tr><th>Annotation</th><th>Description</th></tr></thead><tbody>
<tr><td>@name</td><td>name to be used when generating types. It will override the default name (variable name) and it will be formatted in camelcase.</td></tr>
<tr><td>@db</td><td>name of the database you'd like to use for the query. By default it will use <code>default</code></td></tr>
</tbody></table>
</div>
<pre><code class="language-typescript">// example
const someQuery = sql`
-- @name: simpleQuery
-- @db: mysql
SELECT *
FROM items;
`
</code></pre>
<p>Above example query will generate following types</p>
<pre><code class="language-typescript">export type SimpleQueryParams = []

export interface ISimpleQueryResult {
    id: string
    points: number
}

export interface ISimpleQueryQuery{
    params: SimpleQueryParams;
    result: ISimpleQueryResult;
}
</code></pre>
<p>Note that types are generated with <code>SimpleQuery</code> namespace instead of the variable name <code>SomeQuery</code>. This is the result of setting <code>@name</code> annotation
in the query. Also, it will use <code>mysql</code> database connection that you configured in <code>.sqlxrc.json</code> as a result of setting <code>@db</code>.</p>
<h1 id="overrides"><a class="header" href="#overrides">Overrides</a></h1>
<p>sqlx-ts cannot generate typing for complex SQL syntax such as JSON functions. In this scenario, sqlx-ts will return <code>any</code> and you can use annotations
to override the result to a type that you anticipate.</p>
<h2 id="supported-types"><a class="header" href="#supported-types">Supported types</a></h2>
<p>Type override supports these types <code>string</code>, <code>number</code>, <code>boolean</code>, <code>object</code>, <code>null</code>, <code>any</code>, and <code>never</code></p>
<h2 id="overriding-results"><a class="header" href="#overriding-results">Overriding results</a></h2>
<pre><code class="language-typescript">const someQuery = sql`
-- @result points: number | null
SELECT
    id,
    JSON_EXTRACT(items.c, &quot;$.points&quot;) as points
FROM items
`
</code></pre>
<p>would generate</p>
<pre><code class="language-typescript">export type SimpleQueryParams = []

export interface ISimpleQueryResult {
    id: string
    points: number
}

export interface ISimpleQueryQuery{
    params: SimpleQueryParams;
    result: ISimpleQueryResult;
}
</code></pre>
<p>It's important that you give it an alias so sqlx-ts can match it with your custom annotation.</p>
<blockquote>
<p>Rust provides pattern matching that enforces you to handle all patterns of an enum.
Based on this, we can exhaustively handle all SQL syntax and narrow down the patterns that sqlx-ts cannot handle.
If you ever use following SQL syntax, it is encouraged to override the type using @result annotation.</p>
</blockquote>
<h2 id="overriding-params"><a class="header" href="#overriding-params">Overriding params</a></h2>
<p>Overriding generated type for a param works by adding an annotation <code>-- @param &lt;index&gt;: type</code>. </p>
<ul>
<li><code>index</code> is the position of the query parameter within your SQL</li>
<li>type is the type to override</li>
</ul>
<h3 id="mysql-3"><a class="header" href="#mysql-3">MySQL</a></h3>
<p>If you have a MySQL query like following, you can override param types like in the example below</p>
<pre><code class="language-typescript">const someQuery = sql`
-- @db: mysql
-- @param 1: number
-- @param 2: string
SELECT
    id, points
FROM items
WHERE points &lt; ?
AND name = ?
`
</code></pre>
<p>it would generate the following type definitions</p>
<pre><code class="language-typescript">export type SimpleQueryParams = [number, string]

export interface ISimpleQueryResult {
    id: string
    points: number
}

export interface ISimpleQueryQuery{
    params: SimpleQueryParams;
    result: ISimpleQueryResult;
}
</code></pre>
<h3 id="postgres"><a class="header" href="#postgres">Postgres</a></h3>
<p>If you have a Postgres query like following, you can override param types like in the example below</p>
<pre><code class="language-typescript">const someQuery = sql`
-- @db: postgres
-- @param 1: number
-- @param 2: string
SELECT
    id, points
FROM items
WHERE points &lt; $2
AND name = $1
`
</code></pre>
<p>it would generate the following type definitions</p>
<pre><code class="language-typescript">export type SimpleQueryParams = [string, number]

export interface ISimpleQueryResult {
    id: string
    points: number
}

export interface ISimpleQueryQuery{
    params: SimpleQueryParams;
    result: ISimpleQueryResult;
}
</code></pre>
<p>It will respect the order of query parameters set by you <code>$1</code> and <code>$2</code>, and generate the params in the order that it detects</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Error Code</th><th>Description</th></tr></thead><tbody>
<tr><td>E001</td><td><code>Unable to infer an appropriate name for the query</code> When you have a query in the code but SQLx-ts is unable to correctly infer a name of the query, refer <add a link to the page> for more details</td></tr>
<tr><td>E002</td><td><code>Failed to fetch query name from annotation</code> This error occurs if the query name from the annotation is malformed. @name should be formatted <code>@name: query name</code></td></tr>
<tr><td>E003</td><td><code>Missing alias when handling functions</code> If you are using a SQL function and expect sqlx-ts to generate the type definition for it, you must provide an alias. For example <code>SELECT COUNT(*) AS the_count</code></td></tr>
<tr><td>E004</td><td><code>Invalid TypeScript file path</code></td></tr>
<tr><td>E005</td><td><code>Failed to handle a wildcard statement without target table in FROM statement</code> For some reason, you have a wildcard selection query <code>SELECT * FROM X</code> but the sqlx-ts is unable to pick up the target table. Please double check the SQL query and make sure the target table <code>FROM</code> exists.</td></tr>
<tr><td>E006</td><td><code>Failed to handle a wildcard statement as it reached a dead-end expression</code> You would never hit this error - it would only happen if your wildcard query is not actually a SELECT statement</td></tr>
<tr><td>E007</td><td><code>Unsupported table with joins statement detected</code> You would never reach this unless the query has a malformed FROM statement in your SELECT * query</td></tr>
<tr><td>E008</td><td><code>The query contains unknown placeholder parameter symbol</code> MySQL expects <code>?</code> and PostgreSQL expects <code>$n</code> for query parameter symbols</td></tr>
<tr><td>E009</td><td><code>When translating a function in a SELECT clause, you must provide an alias</code>. functions used as part of SELECT must come with an alias</td></tr>
<tr><td>E010</td><td><code>Unknown function detected while processing a SELECT clause</code> You are using a SQL function that sqlx-ts does not know</td></tr>
<tr><td>E011</td><td><code>table name was not found while processing an identifier</code> FROM is not found in the query</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<h4 id="running-the-binary-simply-returns-1----pid-killed-----sqlx-ts---help"><a class="header" href="#running-the-binary-simply-returns-1----pid-killed-----sqlx-ts---help">Running the binary simply returns <code>[1]    &lt;PID&gt; killed     ./sqlx-ts --help</code></a></h4>
<p>This is because sqlx-ts haven't yet solved the developer license issue described https://users.
rust-lang.org/t/distributing-cli-apps-on-macos/70223/13 for MacOS specifically.</p>
<p>To fix this, you will need to goto <code>System Preferences -&gt; Security &amp; Privacy</code></p>
<img src="https://i.imgur.com/nGjqlgI.png" width="350px">
<p>You will see <code>sqlx-ts</code> binary blocked. Please manually enable it and you can start using sqlx-ts
locally.</p>
<br />
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations"><a class="header" href="#limitations">Limitations</a></h1>
<p>The page aims to list down limitations of sqlx-ts. So for the users who are interested in using the tool, you have a clear idea what are the current limitations. However, as we evolve the tools, some of the limitations would be fixed in the future releases.</p>
<h3 id="1-parsing-of-sql-is-done-using-sqlparser-rs-and-any-bugs-in-this-modules-would-be-inherited"><a class="header" href="#1-parsing-of-sql-is-done-using-sqlparser-rs-and-any-bugs-in-this-modules-would-be-inherited">1. parsing of SQL is done using sqlparser-rs and any bugs in this modules would be inherited</a></h3>
<p><a href="https://github.com/sqlparser-rs/sqlparser-rs">sqlparser-rs</a> is an essential module of sqlx-ts in order to process SQLs into Typescript type definitions. As a result, any bug in this module will be inherited to sqlx-ts and we will need an update in the module in order to fix the problem. So far, sqlparser-rs is well maintained and being updated in the recent days.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
